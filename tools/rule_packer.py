#!/usr/bin/env python3
"""
è§„åˆ™æ‰“åŒ…å·¥å…·
å°†å¤šä¸ª YARA è§„åˆ™æ‰“åŒ…æˆå•ä¸ªæ–‡ä»¶
"""

import os
import sys
import argparse
from pathlib import Path
from typing import List


class RulePacker:
    """è§„åˆ™æ‰“åŒ…å™¨"""
    
    def __init__(self):
        self.rules_content = []
        self.rules_count = 0
    
    def add_rule_file(self, file_path: Path) -> bool:
        """
        æ·»åŠ è§„åˆ™æ–‡ä»¶
        
        Args:
            file_path: è§„åˆ™æ–‡ä»¶è·¯å¾„
            
        Returns:
            æ˜¯å¦æ·»åŠ æˆåŠŸ
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            self.rules_content.append(f"// Rule from: {file_path.name}\n{content}\n")
            self.rules_count += 1
            print(f"âœ… æ·»åŠ è§„åˆ™: {file_path.name}")
            return True
            
        except Exception as e:
            print(f"âŒ è¯»å–å¤±è´¥ [{file_path.name}]: {e}")
            return False
    
    def scan_directory(self, directory: Path, recursive: bool = True):
        """
        æ‰«æç›®å½•ä¸­çš„è§„åˆ™æ–‡ä»¶
        
        Args:
            directory: è§„åˆ™ç›®å½•
            recursive: æ˜¯å¦é€’å½’
        """
        pattern = '**/*.yar*' if recursive else '*.yar*'
        rule_files = list(directory.glob(pattern))
        
        print(f"\nğŸ“‚ æ‰«æç›®å½•: {directory}")
        print(f"ğŸ“„ æ‰¾åˆ° {len(rule_files)} ä¸ªè§„åˆ™æ–‡ä»¶\n")
        
        for file_path in rule_files:
            self.add_rule_file(file_path)
    
    def pack(self, output_path: Path, include_header: bool = True):
        """
        æ‰“åŒ…è§„åˆ™åˆ°æ–‡ä»¶
        
        Args:
            output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„
            include_header: æ˜¯å¦åŒ…å«æ–‡ä»¶å¤´
        """
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                if include_header:
                    f.write("/*\n")
                    f.write(" * YARA Rules Collection\n")
                    f.write(f" * Total Rules: {self.rules_count}\n")
                    f.write(" * Generated by YARA-X Manager\n")
                    f.write(" */\n\n")
                
                f.write("\n".join(self.rules_content))
            
            print(f"\nâœ… æ‰“åŒ…å®Œæˆ!")
            print(f"ğŸ“¦ è¾“å‡ºæ–‡ä»¶: {output_path}")
            print(f"ğŸ“Š è§„åˆ™æ•°é‡: {self.rules_count}")
            print(f"ğŸ’¾ æ–‡ä»¶å¤§å°: {output_path.stat().st_size / 1024:.2f} KB")
            
        except Exception as e:
            print(f"âŒ æ‰“åŒ…å¤±è´¥: {e}")
            sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description='è§„åˆ™æ‰“åŒ…å·¥å…· - åˆå¹¶å¤šä¸ª YARA è§„åˆ™æ–‡ä»¶'
    )
    parser.add_argument(
        '-i', '--input',
        type=str,
        required=True,
        help='è¾“å…¥ç›®å½•æˆ–æ–‡ä»¶'
    )
    parser.add_argument(
        '-o', '--output',
        type=str,
        required=True,
        help='è¾“å‡ºæ–‡ä»¶è·¯å¾„'
    )
    parser.add_argument(
        '-r', '--recursive',
        action='store_true',
        help='é€’å½’æ‰«æå­ç›®å½•'
    )
    parser.add_argument(
        '--no-header',
        action='store_true',
        help='ä¸åŒ…å«æ–‡ä»¶å¤´'
    )
    
    args = parser.parse_args()
    
    # éªŒè¯è¾“å…¥è·¯å¾„
    input_path = Path(args.input)
    if not input_path.exists():
        print(f"âŒ é”™è¯¯: è·¯å¾„ä¸å­˜åœ¨ [{input_path}]")
        sys.exit(1)
    
    # åˆ›å»ºæ‰“åŒ…å™¨
    packer = RulePacker()
    
    # æ·»åŠ è§„åˆ™
    if input_path.is_file():
        packer.add_rule_file(input_path)
    else:
        packer.scan_directory(input_path, args.recursive)
    
    # æ‰“åŒ…
    output_path = Path(args.output)
    packer.pack(output_path, not args.no_header)


if __name__ == '__main__':
    main()
